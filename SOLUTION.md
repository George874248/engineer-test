# Решение тестового задания

## Описание решения

### Архитектура решения

Решение основано на принципе **денормализации данных** для оптимизации производительности операций чтения. Основная идея заключается в том, чтобы хранить в записях сотрудников не только ссылки на связанные сущности (city, division, position), но и их названия напрямую.

### Структура данных

#### Денормализованная структура EmployeeRecord

Вместо хранения только UUID связанных сущностей, запись сотрудника в БД содержит:

```typescript
interface EmployeeRecord {
  uuid: string;
  firstName: string;
  lastName: string;
  divisionUuid: string;
  divisionName: string;      // Денормализованное поле
  cityUuid: string;
  cityName: string;          // Денормализованное поле
  positionUuid: string;
  positionName: string;      // Денормализованное поле
}
```

#### Структура файлов

- `types.ts` - Определение типов данных для всех сущностей системы
- `repository.ts` - Слой доступа к данным (Data Access Layer), инкапсулирует логику работы с БД
- `index.ts` - Реализация интерфейса IHRApp и бизнес-логика

### Реализованные методы

#### `employeeWithCityList()`

Возвращает список сотрудников с названиями городов. Выполняет один запрос к БД (`query` с `type: "employee"`) и извлекает уже готовые данные из денормализованной структуры.

**Производительность**: O(1) запросов к БД, нет необходимости в JOIN или дополнительных запросах.

#### `employeeWithPositionList()`

Возвращает список сотрудников с должностями и подразделениями. Аналогично первому методу, использует один запрос и извлекает данные из денормализованных полей.

**Производительность**: O(1) запросов к БД.

### Аргументация решений

#### 1. Денормализация данных

**Почему денормализация?**
- Контекст задачи указывает на **очень большое количество операций чтения** и **малое количество операций записи**
- База данных является узким местом в производительности
- При денормализации мы жертвуем объемом хранилища (дублируем данные) ради скорости чтения

**Преимущества:**
- Минимизация количества запросов к БД (1 запрос вместо N+1 или JOIN)
- Устранение необходимости в сложных JOIN операциях
- Данные уже готовы к использованию без дополнительной обработки
- Меньше нагрузка на БД при операциях чтения

**Недостатки:**
- Увеличение объема хранилища (незначительное для данного случая)
- Необходимость обновления денормализованных данных при изменении связанных сущностей (но операции записи редкие)

#### 2. Использование UUID как идентификаторов

**Почему UUID?**
- UUID уже используются в исходных данных
- UUID обеспечивают глобальную уникальность
- Подходят для распределенных систем

#### 3. Разделение на слои (Repository Pattern)

**Почему Repository?**
- Инкапсуляция логики доступа к данным
- Упрощение тестирования (можно мокировать Repository)
- Централизация работы с БД
- Легкость изменения реализации в будущем

#### 4. Хранение исходных сущностей отдельно

Хотя в задании не требуется реализовывать методы записи, структура данных предполагает, что:
- Сущности City, Division, Position хранятся отдельно с `type: "city"`, `type: "division"`, `type: "position"`
- Сотрудники хранятся с `type: "employee"` и содержат денормализованные данные
- При обновлении связанных сущностей необходимо будет обновлять соответствующие поля во всех записях сотрудников

### Предположения

1. **Структура хранения в БД**: Предполагается, что каждая запись имеет поле `type` для фильтрации по типу сущности, и данные хранятся в поле `data` объекта записи.

2. **Идентификаторы**: UUID используется как `id` в записи БД (или может быть отдельным полем в `data`, в зависимости от реализации БД).

3. **Производительность query**: Предполагается, что запросы по `type` индексированы и выполняются эффективно.

4. **Целостность данных**: Предполагается, что денормализованные данные поддерживаются в актуальном состоянии при операциях записи (которые не требуются в данной задаче).

---

## Ответ на вопрос 3

### Изменится ли решение, если контекст подразумевает редкие операции чтения и на порядок большее количество операций записи?

**Да, решение кардинально изменится.**

### Новая стратегия для сценария "много записей, мало чтений"

#### 1. Нормализация данных (вместо денормализации)

**Структура Employee:**

```typescript
interface Employee {
  uuid: string;
  firstName: string;
  lastName: string;
  divisionUuid: string;  // Только ссылка
  cityUuid: string;      // Только ссылка
  positionUuid: string;  // Только ссылка
}
```

**Преимущества:**
- Минимальный объем хранилища (нет дублирования)
- Быстрые операции записи/обновления (меняем только одну запись)
- Соответствие нормальным формам БД
- Легкость поддержания целостности данных

#### 2. Оптимизация операций записи

**Стратегии:**

1. **Пакетные операции записи**
   - Группировка множественных обновлений в транзакции
   - Batch insert/update операции

2. **Асинхронная обработка**
   - Записи в очередь для последующей обработки
   - Write-behind кэширование

3. **Индексация**
   - Индексы на часто изменяемые поля
   - Индексы на внешние ключи (cityUuid, divisionUuid, positionUuid)

#### 3. Оптимизация редких операций чтения

**Для методов чтения:**

1. **Кэширование результатов**
   - Использование in-memory кэша (Redis, Memcached)
   - Кэширование результатов запросов
   - TTL для инвалидации кэша

2. **Ленивая загрузка (Lazy Loading)**
   - Загрузка связанных данных только при необходимости
   - Можно использовать кэш на уровне приложения

3. **Materialized Views или агрегаты**
   - Предвычисленные представления для частых запросов
   - Обновление через триггеры или асинхронные процессы

#### 4. Архитектурные изменения

**Новый подход:**

```typescript
// Оптимизированное чтение через JOIN или несколько запросов
// + кэширование результатов

class HRRepository {
  private cache: Map<string, any>;
  
  async getEmployeesWithCities(): Promise<EmployeeWithCity[]> {
    const cacheKey = 'employees-with-cities';
    
    // Проверка кэша
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }
    
    // Загрузка данных (может быть медленной, но редкой)
    const employees = await this.getEmployees();
    const cities = await this.getCities();
    const cityMap = new Map(cities.map(c => [c.uuid, c.name]));
    
    const result = employees.map(emp => ({
      firstName: emp.firstName,
      city: cityMap.get(emp.cityUuid) || ''
    }));
    
    // Кэширование
    this.cache.set(cacheKey, result);
    
    return result;
  }
}
```

#### 5. Сравнение подходов

| Критерий | Текущее решение (много чтений) | Альтернатива (много записей) |
|----------|-------------------------------|------------------------------|
| Структура данных | Денормализованная | Нормализованная |
| Запросы чтения | 1 запрос, готовые данные | N запросов или JOIN + кэш |
| Запросы записи | Много обновлений (редко) | 1 обновление (часто) |
| Объем хранилища | Больше (дублирование) | Меньше (без дублирования) |
| Сложность обновлений | Высокая (синхронизация) | Низкая (одна запись) |
| Кэширование | Не требуется | Критично важно |

#### 6. Гибридный подход (компромисс)

Если нужно балансировать между чтением и записью:

1. **Частичная денормализация**
   - Денормализация только самых часто читаемых полей
   - Остальные поля нормализованы

2. **Eventual Consistency**
   - Обновление денормализованных данных асинхронно
   - Возможна небольшая задержка консистентности

3. **CQRS (Command Query Responsibility Segregation)**
   - Разделение моделей для чтения и записи
   - Модель записи - нормализованная
   - Модель чтения - денормализованная, обновляется через события

### Вывод

Решение полностью зависит от паттерна использования:
- **Много чтений, мало записей** → Денормализация + готовые данные
- **Много записей, мало чтений** → Нормализация + кэширование + оптимизация записей

В данном случае выбор денормализации оптимален для указанного контекста.

---

## Контакты

*Контакты можно добавить здесь, если необходимо*
